#!/bin/bash

# shellcheck disable=SC1090

read -r -d '' doc << "EOM"
Initializes a new file (`TARGET`) using a predefined template (`TEMPLATE`).
The target file can be a new script, configuration file, markup file, etc....
After the target file has been initialized, it is opened for editing using the
system's default editor.
EOM

# ---------- Source Libraries / Configs ----------
source /usr/lib/gutils.sh
MY_XDG_DATA="${MY_XDG_DATA}"

[ -d "${MY_XDG_CONFIG}" ] || mkdir -p "${MY_XDG_CONFIG}"
[ -d "${MY_XDG_DATA}" ] || mkdir -p "${MY_XDG_DATA}"

read -r -d '' default_config << "EOM"
# The target file will be initialized in a location relative to this directory
# unless you specify the `-f` option. In which case the target file will be
# initialized relative to the current directory.
#
# Defaults to "./" (the current directory).
PARENT_BIN_DIR=

# The target file is initialized in $PARENT_BIN_DIR/$DEFAULT_BIN_SUBDIR
# unless the `-D {DIR}` option is used. In which case the target file will
# be initialized to $PARENT_BIN_DIR/{DIR}.
DEFAULT_BIN_SUBDIR=

# If specified, this command is evaluated after (and if) the target file
# has its executable bit set. This can be used to create symlinks to
# the target file (using `stow`, for example).
#
# The $TARGET variable, which contains the full path of the target file,
# will be injected into the environment of this command.
EXEC_HOOK_CMD=
EOM

config_file="${MY_XDG_CONFIG}"/config
if [[ -f "${config_file}" ]]; then
    source "${config_file}"
else
    imsg "Configruation file has been initialized."
    echo "${default_config}" > "${config_file}"
fi

# Set default bin directory if not specified in config file.
if [[ -z "${PARENT_BIN_DIR}" ]]; then
    PARENT_BIN_DIR=./
fi

# ---------- Function Definitions ----------
function get_start_line() {
    mark="$1"; shift
    grep -n "${mark}" "${full_new_script_name}" | awk -F':' '{print $1}'
    sed -i "s/${mark}//" "${full_new_script_name}"
}

function open_editor() {
    start_line="$1"; shift
    mode="$1"; shift

    if [[ "${editor}" == *"vim"* ]]; then
        Vim_Opts=()
        if [[ -n "${start_line}" ]]; then
            Vim_Opts+=( +"${start_line}" )
        fi

        if [[ "${mode}" == "INSERT" ]]; then
            Vim_Opts+=( +startinsert )
        fi
        
        ${editor} "${Vim_Opts[@]}" "${full_new_script_name}"
    else
        ${editor} "${full_new_script_name}"
    fi
}

# ---------- Command-line Arguments ----------
eval set -- "$(getopt -o "d,c,D:,e:,f,F:,h,l,N,T:,v,x" -l "config,debug,docs:,bin-subdir:,edit:,help,list,executable:,template:,verbose,use-extension:" -- "$@")"

USAGE="${USAGE} [-c] [-d] [-D BIN_SUBDIR] [-e TEMPLATE] [-f] [-h] [-N | --executable={y|n}] [-x | --use-extension={y|n}] [-v] [-T TEMPLATE] TARGET"
SCRIPTNAME="${SCRIPTNAME}"

# shellcheck disable=SC2153
if [[ -n "${EDITOR}" ]]; then
    editor="${EDITOR}"
else
    editor="vim"
fi

read -r -d '' help << EOM
${USAGE^}

${doc}

Command-line Options:
    -d | --debug
        Enable debug mode.

    -c | --config
        Edit the configuration file.

    -D DIR | --bin-subdir DIR
        Initialize TARGET into DIR, which should be a subdirectory of the
        default bin directory (see the configuration file).

    -e TEMPLATE | --edit TEMPLATE
        Edit cookie template.

    --executable={y|n}
        Make TARGET executable. Defaults to 'y'.

    -f | --force
        Force TARGET initialization to be relative to the current
        directory.

    -h | --help
        View this help message.

    -l | --list
        List available templates.

    -N
        Equivalent to --executable=n.

    -T TEMPLATE | --template TEMPLATE
        The name of the template (e.g. mytemplate.sh).

    --use-extension={y|n}
        Append file extension to TARGET. Defaults to 'n'.

    -x
        Equivalent to --use-extension=y

    -v | --verbose
        Enable verbose output.
EOM

executable="y"
use_extension="n"
while [[ -n "$1" ]]; do
    case $1 in
       -c|--config )
           "${editor}" "${config_file}"
           exit 0
           ;;
       -d|--debug )
           debug=true
           ;;
       -e|--edit )
           shift
           full_template_name="${MY_XDG_DATA}"/"$1"
           if ! [[ -f "${full_template_name}" ]]; then
               die "The template does not exist: ${full_template_name}"
           fi
           "${editor}" "${full_template_name}"
           exit 0
           ;;
       -h|--help )
           echo "$help"
           exit 0
           ;;
       -l|--list )
           for T in "${MY_XDG_DATA}"/*; do
               basename "${T}"
           done
           exit 0
           ;;
       -D|--bin-subdir )
           shift
           BIN_SUBDIR="$1"
           ;;
       --docs )
           shift
           eval "printf -- \"\${$1}\n\""
           exit 0 
           ;;
       --executable )
           shift
           executable="$1"
           ;;
       -f )
           force=true
           ;;
       -N )
           executable="n"
           ;;
       --use-extension )
           shift
           use_extension="$1"
           ;;
       -T|--template )
           shift
           template="$1"
           ;;
       -v|--verbose )
           verbose=true
           ;;
       -x )
           use_extension="y"
           ;;
       -- )
           shift
           break
           ;;
    esac
    shift
done

if [[ "${debug}" = true && "${verbose}" = true ]]; then
    PS4='$LINENO: '
    set -x
fi

if [[ -z "$1" ]] || [[ -z "${template}" ]]; then
    die "${USAGE}" 2
fi

# ---------- Traps ----------
function exit_handler() {
    EC="$1"; shift

    if [[ "${parent_dir_created}" = true && "${EC}" -ne 0 ]]; then
        dmsg "Removing directory: ${full_bin_path}"
        rm -rf "${full_bin_path}"
    fi
}

trap 'exit_handler $?' EXIT

# ---------- Global Variables ----------
new_script_name="$1"; shift
if [[ "${template}" == *"."* ]]; then
    extension="${template##*.}"
fi

# ---------- Main ----------
# ===== Calculate Filesystem Paths =====
if [[ "$(pwd)" == "$PARENT_BIN_DIR/"* && -z "$BIN_SUBDIR" ]] || [[ "$force" = true ]]; then
    full_bin_path="$(pwd)"
elif [[ -z "$BIN_SUBDIR" ]]; then
    full_bin_path="$PARENT_BIN_DIR"/"$DEFAULT_BIN_SUBDIR"
else
    full_bin_path="$PARENT_BIN_DIR"/"$BIN_SUBDIR"
fi

new_script_parent_dir="$(dirname "${new_script_name}")"
if [[ "${new_script_parent_dir}" != "." ]]; then
    full_bin_path="${full_bin_path}"/"${new_script_parent_dir}"
    new_script_name="$(basename "${new_script_name}")"
fi

if [[ "$full_bin_path" != "./"* ]]; then
    if ! [[ -d "${full_bin_path}" ]]; then
        dmsg "Creating directory: ${full_bin_path}"
        mkdir -p "${full_bin_path}"
        parent_dir_created=true
    fi

    cd "$full_bin_path" || exit 1
    imsg "Entering $full_bin_path."
fi

if [[ "${use_extension}" == "y" || "${use_extension}" == "yes" ]]; then
    full_new_script_name="${new_script_name}.${extension}"
else
    full_new_script_name="${new_script_name}"
fi

full_template_name="${MY_XDG_DATA}"/"${template}"
if ! [[ -f "${full_template_name}" ]]; then
    die "Template does not exist: ${full_template_name}"
fi

imsg "Found matching template: $(basename "${full_template_name}")"

# ===== Initialize New Script =====
# >>> Copy Template Contents to New Script
if ! [[ -f "$full_new_script_name" ]]; then
    imsg "Initializing the '$full_new_script_name' script."
    cp "${full_template_name}" "${full_new_script_name}"
else
    imsg "The '$full_new_script_name' script already exists."
    open_editor "${start_line}"
    exit 0
fi

# >>> Make New Script Executable
if [[ "${executable}" == "y" || "${executable}" == "yes" ]]; then
    sudo chmod +x "$full_new_script_name"
    if [[ -n "${EXEC_HOOK_CMD}" ]]; then
        imsg "Running execute hook: ${EXEC_HOOK_CMD}"
        eval "TARGET=${full_new_script_name} ${EXEC_HOOK_CMD}"
    fi
fi

# ===== Template Statements and Substitutions =====
# >>> START HERE
istart_mark="{% START INSERT MODE %}"
istart_line="$(get_start_line "${istart_mark}")"

nstart_mark="{% START NORMAL MODE %}"
nstart_line="$(get_start_line "${nstart_mark}")"

if [[ -n "${istart_line}" ]]; then
    mode="INSERT"
    start_line="${istart_line}"
elif [[ -n "${nstart_line}" ]]; then
    mode="NORMAL"
    start_line="${nstart_line}"
fi

# >>> Environment Variable Replacements
grep_epttrn="{{ (.*?) }}"
sed_epttrn="{{ \([^ ]*\) }}"

exec 5>&1  # save STDIN
while read evar; do
    evalue="$(eval "echo \"\$${evar}\"")"
    if [[ -z "${evalue}" ]]; then
        read -p "${evar}: " evalue <&5
    fi

    sed -i "s/${sed_epttrn}/${evalue}/" "${full_new_script_name}"
done < <(grep -P -o "${grep_epttrn}" "${full_new_script_name}" | sed "s/${sed_epttrn}/\1/" | sed 's/cookiecutter\.//')

# ===== Open New Script in Editor =====
open_editor "${start_line}" "${mode}"
